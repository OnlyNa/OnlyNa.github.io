<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫的博客</title>
  <icon>https://www.gravatar.com/avatar/bdb35f9a83477352e04d0da073b0b661</icon>
  <subtitle>快乐学习</subtitle>
  <link href="https://onlyna.github.io/atom.xml" rel="self"/>
  
  <link href="https://onlyna.github.io/"/>
  <updated>2024-09-06T17:40:16.800Z</updated>
  <id>https://onlyna.github.io/</id>
  
  <author>
    <name>枫</name>
    <email>hjf0417@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Codeium - AI代码辅助工具</title>
    <link href="https://onlyna.github.io/everyday/codeium/"/>
    <id>https://onlyna.github.io/everyday/codeium/</id>
    <published>2024-09-04T05:56:12.000Z</published>
    <updated>2024-09-06T17:40:16.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeium简介"><a href="#Codeium简介" class="headerlink" title="Codeium简介"></a>Codeium简介</h1><blockquote><p>Codeium是一个基于尖端人工智能技术构建的免费AI代码加速工具包。它提供代码补全、智能搜索和支持20多种语言的AI聊天功能。Codeium可用于所有流行的集成开发环境（IDE），包括Visual Studio Code、IntelliJ IDEA和Eclipse。</p></blockquote><h2 id="Codeium特点"><a href="#Codeium特点" class="headerlink" title="Codeium特点"></a>Codeium特点</h2><ul><li>比想象中更快地获得代码补全。Codeium的生成式代码可以节省时间，帮助您更快地发布产品。</li><li>通过智能搜索找到与其意图相关的文件和代码。不再与复杂的正则表达式纠缠不清，使用我们的AI搜索来找到与您意图相关的文件和代码。</li><li>从Codeium Chat获得帮助。生成样板代码、重构代码、添加文档、解释代码、建议错误修复等等。</li></ul><h2 id="Codeium功能"><a href="#Codeium功能" class="headerlink" title="Codeium功能"></a>Codeium功能</h2><ul><li>代码补全：Codeium可以根据您当前代码的上下文自动为您完成代码。这可以节省您很多时间，特别是对于大型或复杂的项目。</li><li>智能搜索：Codeium可以搜索与您意图相关的文件和代码。这是一种快速轻松找到所需代码的好方法。</li><li>AI聊天支持：Codeium可以帮助您完成各种编码任务，例如生成样板代码、重构代码和添加文档。您还可以使用Codeium</li><li>Chat在更复杂的编码任务中获得AI的帮助。</li></ul><h2 id="Codeium优势"><a href="#Codeium优势" class="headerlink" title="Codeium优势"></a>Codeium优势</h2><ul><li>节省时间：Codeium可以通过自动为您补全代码、搜索与您意图相关的文件和代码以及帮助您完成各种编码任务来帮助您节省时间。</li><li>提高代码质量：Codeium可以通过提供更好的编码方式的建议和对您的代码的反馈来帮助您提高代码质量。</li><li>从人工智能中获得帮助：Codeium可以通过提供对您的代码的建议和反馈、生成样板代码、重构代码和添加文档等方式来帮助您从人工智能中获得帮助。</li></ul><h1 id="Codeium-下载使用"><a href="#Codeium-下载使用" class="headerlink" title="Codeium 下载使用"></a>Codeium 下载使用</h1><h2 id="Codeium-下载"><a href="#Codeium-下载" class="headerlink" title="Codeium 下载"></a>Codeium 下载</h2><p>Codeium支持Studio Code、IntelliJ IDEA和Eclipse等编程工具，下面使用Clion（IntelliJ IDEA）作为示例：</p><ol><li>打开Clion插件安装界面<br><img src="/../images/Snipaste_2024-09-04_14-38-28.png" alt="Snipaste_2024-09-04_14-38-28.png"></li><li>在插件界面搜索Codeium并选中第一个点击下载，并在下载完成后重启IDE<br><img src="/../images/Snipaste_2024-09-04_14-43-52.png" alt="Snipaste_2024-09-04_14-43-52.png"></li></ol><h2 id="Codeium-使用"><a href="#Codeium-使用" class="headerlink" title="Codeium 使用"></a>Codeium 使用</h2><ol start="3"><li>点击右下角<code>Codeium</code>登录,此时会打开登录页面登录Codeium<br><img src="/../images/Snipaste_2024-09-04_14-48-58.png" alt="Snipaste_2024-09-04_14-48-58.png"></li><li>登录成功后，Codeium会下载语言服务器，下载完成后即可使用</li><li><img src="/../images/Snipaste_2024-09-04_14-55-24.png" alt="Snipaste_2024-09-04_14-55-24.png"></li><li>使用示例，编写注释，让AI插件帮助我们生成代码，以生成一个快速排序为例：<br><img src="/../images/Snipaste_2024-09-05_09-15-13.png" alt="Snipaste_2024-09-05_09-15-13.png"><br><img src="/../images/Snipaste_2024-09-05_09-15-35.png" alt="Snipaste_2024-09-05_09-15-35.png"></li></ol><h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a><em>题外</em></h1><p>当点击登录无响应时，可以通过手动获取ToKen登录，方法如下：<br><img src="/../images/Snipaste_2024-09-05_09-19-30.png" alt="Snipaste_2024-09-05_09-19-30.png"><br><img src="/../images/Snipaste_2024-09-05_09-21-09.png" alt="Snipaste_2024-09-05_09-21-09.png"><br><img src="/../images/Snipaste_2024-09-05_09-22-39.png" alt="Snipaste_2024-09-05_09-22-39.png"><br><img src="/../images/Snipaste_2024-09-05_09-24-03.png" alt="Snipaste_2024-09-05_09-24-03.png"><br>登录完成！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Codeium简介&quot;&gt;&lt;a href=&quot;#Codeium简介&quot; class=&quot;headerlink&quot; title=&quot;Codeium简介&quot;&gt;&lt;/a&gt;Codeium简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Codeium是一个基于尖端人工智能技术构建的免费AI代码</summary>
      
    
    
    
    
    <category term="日常" scheme="https://onlyna.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>C++ 17 内联变量</title>
    <link href="https://onlyna.github.io/cplusplus/inline/"/>
    <id>https://onlyna.github.io/cplusplus/inline/</id>
    <published>2024-09-03T09:54:09.000Z</published>
    <updated>2024-09-06T17:40:16.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-17-内联变量"><a href="#C-17-内联变量" class="headerlink" title="C++ 17 内联变量"></a>C++ 17 内联变量</h1><blockquote><p><strong>C++17</strong> 引入了<code>内联变量</code>（inline variables）这一特性，旨在解决静态成员变量和全局变量在跨翻译单元中重复定义的问题。通过引入内联变量，<strong>C++17</strong>使得这些变量可以在多个翻译单元中定义而不会导致链接错误。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 <strong>C++17</strong> 之前，如果你有一个静态的或全局的常量变量，并且它的定义出现在多个翻译单元中，你可能会遇到链接错误（multiple<br>definition error）。通常你需要在头文件中声明变量，在一个源文件中定义它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">42</span>; <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// source.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MyClass::value; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure><p>如果你不小心在多个源文件中定义 <strong>value</strong>，会导致链接错误。</p><h2 id="C-17-内联变量-1"><a href="#C-17-内联变量-1" class="headerlink" title="C++17 内联变量"></a>C++17 内联变量</h2><p>为了简化这个过程，<strong>C++17</strong> 引入了<code>内联变量</code>。通过使用 <code>inlines</code> 关键字，你可以在头文件中同时声明和定义静态或全局变量，并且可以在多个翻译单元中包含此头文件而不会导致链接错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">42</span>; <span class="comment">// 声明和定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>MyClass::value</strong>可以在任何地方直接使用 ，而不会出现链接错误。</p><h2 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h2><ol><li><strong>避免链接错误</strong>：内联变量可以在头文件中定义，而不会导致多个翻译单元中的重复定义问题。</li><li><strong>简化代码</strong>：不再需要将静态成员变量或全局常量拆分为声明和定义两部分，可以直接在头文件中定义。</li><li><strong>更好的模块化</strong>：内联变量可以在头文件中直接使用，增强了模块化和代码复用性。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>C++17</strong>的内联变量特性为开发者提供了一种更方便的方式来处理静态和全局常量。通过内联变量，开发者可以避免重复定义的问题，同时简化代码结构，使得在多个翻译单元中使用这些变量变得更加容易和安全。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-17-内联变量&quot;&gt;&lt;a href=&quot;#C-17-内联变量&quot; class=&quot;headerlink&quot; title=&quot;C++ 17 内联变量&quot;&gt;&lt;/a&gt;C++ 17 内联变量&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;C++17&lt;/strong&gt; 引入</summary>
      
    
    
    
    <category term="C++" scheme="https://onlyna.github.io/categories/C/"/>
    
    
    <category term="C++ 17" scheme="https://onlyna.github.io/tags/C-17/"/>
    
  </entry>
  
  <entry>
    <title>C++ 17 if-switch初始化</title>
    <link href="https://onlyna.github.io/cplusplus/if-switch/"/>
    <id>https://onlyna.github.io/cplusplus/if-switch/</id>
    <published>2024-09-03T09:42:53.000Z</published>
    <updated>2024-09-06T17:40:16.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-17-if-switch初始化"><a href="#C-17-if-switch初始化" class="headerlink" title="C++ 17 if-switch初始化"></a>C++ 17 if-switch初始化</h1><blockquote><p><strong>C++17</strong>引入了一个非常有用的特性，使得 <strong>if</strong> 和 <strong>switch</strong> 语句支持初始化语句。这个特性允许你在 <strong>if</strong> 或 <strong>switch</strong><br>语句中直接初始化一个变量，这样可以更方便地将变量的作用域限制在 <strong>if</strong> 或 <strong>switch</strong> 语句的块中，避免污染外部作用域。</p></blockquote><h2 id="if语句初始化"><a href="#if语句初始化" class="headerlink" title="if语句初始化"></a>if语句初始化</h2><p>在 <strong>C++17</strong>之前，你通常需要在 <code>if</code> 语句外部初始化变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="built_in">someFunction</span>();</span><br><span class="line"><span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++17</strong> 引入了以下的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="type">int</span> value = <span class="built_in">someFunction</span>(); value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，<strong>value</strong> 的作用域仅限于 <strong>if</strong> 语句及其后续的 <strong>else</strong> 块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="type">int</span> value = <span class="built_in">someFunction</span>(); value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value is positive: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value is non-positive: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这里，value 已经超出了作用域</span></span><br></pre></td></tr></table></figure><h2 id="switch语句初始化"><a href="#switch语句初始化" class="headerlink" title="switch语句初始化"></a>switch语句初始化</h2><p><strong>switch</strong>语句同样支持这种初始化方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="type">int</span> value = <span class="built_in">someFunction</span>(); value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value is 1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value is 2\n&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value is &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>value</code> 的作用域同样被限制在 <code>switch</code> 语句的范围内。这样做的好处是可以避免变量泄漏到外部作用域，并且代码更加紧凑和清晰。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><strong>作用域限制</strong>：变量的作用域被限制在 <code>if</code> 或 <code>switch</code> 语句块中，避免了意外使用外部变量。</li><li><strong>代码紧凑</strong>：将变量声明和条件判断结合在一起，使代码更加紧凑。</li><li><strong>可读性提高</strong>：由于变量仅在需要的地方存在，代码的可读性得到了提升。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>C++17</strong>的 <code>if</code> 和 <code>switch</code> 语句初始化特性为开发者提供了一个简洁且高效的方式来处理条件语句中的变量初始化。这一特性不仅提高了代码的安全性，还使得代码更易读、易维护。在现代<br>C++ 编程中，这是一个值得推荐的编写模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-17-if-switch初始化&quot;&gt;&lt;a href=&quot;#C-17-if-switch初始化&quot; class=&quot;headerlink&quot; title=&quot;C++ 17 if-switch初始化&quot;&gt;&lt;/a&gt;C++ 17 if-switch初始化&lt;/h1&gt;&lt;blockquo</summary>
      
    
    
    
    <category term="C++" scheme="https://onlyna.github.io/categories/C/"/>
    
    
    <category term="C++ 17" scheme="https://onlyna.github.io/tags/C-17/"/>
    
  </entry>
  
  <entry>
    <title>C++ 17 结构化绑定</title>
    <link href="https://onlyna.github.io/cplusplus/structured_binding/"/>
    <id>https://onlyna.github.io/cplusplus/structured_binding/</id>
    <published>2024-09-03T06:26:41.000Z</published>
    <updated>2024-09-06T17:40:16.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-17-结构化绑定"><a href="#C-17-结构化绑定" class="headerlink" title="C++ 17 结构化绑定"></a>C++ 17 结构化绑定</h1><blockquote><p>C++17 引入的<strong>结构化绑定</strong>（Structured Bindings）是一个非常有用的语言特性，使得解构和访问多个值变得更加简洁和直观。结构化绑定允许你将一个对象或数据结构的多个元素绑定到独立的变量上，这在处理返回多个值的函数或解构容器时非常方便。</p></blockquote><h2 id="语法与使用场景"><a href="#语法与使用场景" class="headerlink" title="语法与使用场景"></a>语法与使用场景</h2><ol><li><p>解构<strong>std::tuple</strong><br> 在 C++17 之前，如果你有一个 <strong>std::tuple</strong> ，需要分别获取其中的元素，通常会使用 std::get：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">getTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="built_in">getTuple</span>();</span><br><span class="line">    <span class="type">int</span> i = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t);</span><br><span class="line">    <span class="type">double</span> d = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t);</span><br><span class="line">    std::string s = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<strong>结构化绑定</strong>，可以将这段代码简化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">getTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [i, d, s] = <span class="built_in">getTuple</span>(); <span class="comment">// 结构化绑定</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，i、d 和 s 分别绑定到 std::tuple 的第 0、1 和 2 个元素上。</p></li><li><p>解构<strong>std::pair</strong><br>std::pair 也是结构化绑定的典型应用场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, std::string&gt; <span class="title">getPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">42</span>, <span class="string">&quot;Answer&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [num, str] = <span class="built_in">getPair</span>(); <span class="comment">// 结构化绑定</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>适用于数组和结构体<br>结构化绑定不仅限于元组和对，还可以用于数组和结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [a, b, c] = arr; <span class="comment">// 解构数组</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于结构体，只要结构体的成员变量是公共的且没有默认的删除构造函数，也可以使用结构化绑定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = p; <span class="comment">// 解构结构体</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用于<strong>std::map</strong>或<strong>std::unordered_map</strong>这类关联容器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; m = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : m) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><strong>结构化绑定</strong>实际上是一个<strong>语法糖</strong>，它在幕后生成了合适的变量并调用相应的 getter 函数（如 <strong>std::get</strong>）来初始化这些变量。这使得代码更加简洁和可读。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><strong>C++17</strong>的结构化绑定是一个强大的特性，极大地简化了多值返回、数组、结构体等的解构过程，使得代码更加直观和简洁。在需要解构数据的场景中，结构化绑定可以显著<strong>提高代码的可读性和维护性</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-17-结构化绑定&quot;&gt;&lt;a href=&quot;#C-17-结构化绑定&quot; class=&quot;headerlink&quot; title=&quot;C++ 17 结构化绑定&quot;&gt;&lt;/a&gt;C++ 17 结构化绑定&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;C++17 引入的&lt;strong&gt;结构化绑</summary>
      
    
    
    
    <category term="C++" scheme="https://onlyna.github.io/categories/C/"/>
    
    
    <category term="C++ 17" scheme="https://onlyna.github.io/tags/C-17/"/>
    
  </entry>
  
  <entry>
    <title>C++17 类模板参数推导</title>
    <link href="https://onlyna.github.io/cplusplus/class_template_argument_deduction/"/>
    <id>https://onlyna.github.io/cplusplus/class_template_argument_deduction/</id>
    <published>2024-09-03T06:07:49.000Z</published>
    <updated>2024-09-06T17:40:16.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-17-类模板参数推导"><a href="#C-17-类模板参数推导" class="headerlink" title="C++17 类模板参数推导"></a>C++17 类模板参数推导</h1><blockquote><p><strong>C++17</strong>引入了<code>类模板参数推导</code> (Class Template Argument Deduction, CTAD)，使得编译器能够在实例化模板类时自动推导出模板参数类型。结合构造函数模板推导，这意味着当你在构造一个类模板的对象时，可以省略模板参数，编译器会根据构造函数的参数自动推导出模板参数。</p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>假设你有一个简单的模板类 Pair，它用于存储两个值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Pair</span>(T1 a, T2 b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <strong>C++17</strong> 之前，你必须显式地指定模板参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">3.14</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>但在 <strong>C++17</strong> 中，你可以省略模板参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pair <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">3.14</span>)</span></span>; <span class="comment">// 编译器会自动推导出 Pair&lt;int, double&gt;</span></span><br></pre></td></tr></table></figure><p>编译器通过构造函数的参数类型自动推导出 T1 和 T2 的类型，因此无需显式指定模板参数。</p><h2 id="推导指南"><a href="#推导指南" class="headerlink" title="推导指南"></a>推导指南</h2><p>有时，编译器可能无法从构造函数的参数推导出所需的模板参数类型。在这种情况下，你可以提供一个推导指南 (Deduction Guide) 来帮助编译器推导模板参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Pair</span>(T1 a, T2 b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 另外一种构造函数</span></span><br><span class="line">    <span class="built_in">Pair</span>(T1 a) : <span class="built_in">first</span>(a), <span class="built_in">second</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里，如果你只传递一个参数，编译器可能无法正确推导 <strong>T2</strong> 的类型。你可以为此提供一个<strong>推导指南</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="built_in">Pair</span>(T1) -&gt; Pair&lt;T1, T1&gt;;</span><br></pre></td></tr></table></figure><p>这个推导指南告诉编译器，当你构造一个 <strong>Pair</strong> 对象并且只传递一个参数时，模板参数 <strong>T2</strong> 应该与 <strong>T1</strong> 相同。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>C++17</strong> 的构造函数模板推导大大简化了模板类的使用，减少了重复代码的需求，并提高了代码的可读性。推导指南提供了进一步的灵活性，允许你自定义模板参数的推导方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-17-类模板参数推导&quot;&gt;&lt;a href=&quot;#C-17-类模板参数推导&quot; class=&quot;headerlink&quot; title=&quot;C++17 类模板参数推导&quot;&gt;&lt;/a&gt;C++17 类模板参数推导&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;C++17&lt;/</summary>
      
    
    
    
    <category term="C++" scheme="https://onlyna.github.io/categories/C/"/>
    
    
    <category term="C++ 17" scheme="https://onlyna.github.io/tags/C-17/"/>
    
  </entry>
  
  <entry>
    <title>lambda表达式</title>
    <link href="https://onlyna.github.io/cplusplus/lambda/"/>
    <id>https://onlyna.github.io/cplusplus/lambda/</id>
    <published>2024-09-01T15:05:47.000Z</published>
    <updated>2024-09-06T17:40:16.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-lambda表达式"><a href="#C-11-lambda表达式" class="headerlink" title="C++11 lambda表达式"></a>C++11 lambda表达式</h1><h2 id="1-简介与使用"><a href="#1-简介与使用" class="headerlink" title="1. 简介与使用"></a>1. 简介与使用</h2><p><code>lambda</code>的历时悠久，不过具体到<strong>C++11</strong>中，<code>lambda</code>函数却显得与之前C++规范下的代码在风格上有较大的区别。举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> addNums= [](<span class="type">int</span> nNum1, <span class="type">int</span> nNum2)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> nNum1 + nNum2; &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;结果：addNums= &quot;</span> &lt;&lt; <span class="built_in">addNums</span>(<span class="number">11</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，定义了一个<strong>lambda函数</strong>，该函数接收两个参数：nNum1和nNum2，并返回两个参数的和；</p><p>在此，lambda相比于普通函数来说，少了函数名，取而代之的是一对<strong>（[]）</strong>；</p><p>此外，<strong>lambda函数</strong>还采用追踪的返回类型的方式声明其返回值。其余反面看起来跟普通函数定义一样。</p><h2 id="2-lambda函数语法定义"><a href="#2-lambda函数语法定义" class="headerlink" title="2. lambda函数语法定义"></a>2. lambda函数语法定义</h2><p>[<strong>capture</strong>] (<strong>parameters</strong>) <strong>mutable</strong> -&gt;<strong>return-&gt;type</strong>{<strong>statement</strong>}</p><ul><li><strong>capture</strong>：捕获列表，用于捕获外部变量</li><li><strong>parameters</strong>：参数列表，跟普通函数参数列表一致，当不传递参数时，可省略。</li><li><strong>mutable</strong>：可变参数。默认情况下，lambda函数是const函数，当lambda函数使用值传递时，mutable使得函数可以const限制，可以修改值传递进来的参数。</li><li><strong>return-&gt;type</strong>：lambda函数的返回类型，可省略，由编译器进行推导。</li><li><strong>statement</strong>：函数体实现，除了可以使用参数列表的参数，也可以使用捕获列表的值。</li></ul><h2 id="3-lambda函数使用"><a href="#3-lambda函数使用" class="headerlink" title="3. lambda函数使用"></a>3. lambda函数使用</h2><h3 id="3-1-捕获方式"><a href="#3-1-捕获方式" class="headerlink" title="3.1 捕获方式"></a>3.1 捕获方式</h3><ul><li><strong>值捕获</strong><br>和传递变量里的传递变量值类型相似，这种捕获方式捕获的也是变量的值，在编译期间，会在Lambda表达式被创建的时候把这个变量复制给局部的一个临时变量，所以这种捕获方式的变量必须是可以被复制的变量。</li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a&#123; <span class="number">1</span> &#125;, b&#123; <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> func = [a]() &#123;a = <span class="number">3</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面面代码编译不通过，编译器提示“表达式必须是可修改的左值”；上面我们提到lambda函数是<strong>const函数</strong>，但使用<br><em>值捕获时，不可修改捕获的变量</em>。</p><p>如下代码块中lambda加入<strong>mutable</strong>，此时编译通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a&#123; <span class="number">1</span> &#125;, b&#123; <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> func = [a]() <span class="keyword">mutable</span>&#123;a = <span class="number">3</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>引用捕获</strong><br>按引用捕获可以让lambda表达式能够访问引用变量，这种捕获方式在编译期间不会把变量的值复制到lambda的局部作用域，而是直接对这个引用所指的变量进行操作。这种方式要求这个引用所指的对象在表达式被执行的时候必须是存在的。</li></ul><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a&#123; <span class="number">1</span> &#125;, b&#123; <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">[] &#123;&#125;;   <span class="comment">// 最简lambda函数</span></span><br><span class="line">[](<span class="type">int</span> a, <span class="type">int</span> b) &#123;a + b; &#125;;<span class="comment">//有参lambda函数</span></span><br><span class="line"></span><br><span class="line">[=]() &#123;<span class="keyword">return</span> a + b; &#125;;<span class="comment">// [=]值传递，不可修改捕获的变量，如果一定要修改，可加入mutable关键字</span></span><br><span class="line">[&amp;]() &#123;a = <span class="number">11</span>; &#125;;<span class="comment">// 引用传递，可修改捕获的变量，无返回值类型</span></span><br><span class="line">[=, &amp;b] &#123;b = <span class="number">22</span>; &#125;;<span class="comment">// 除了变量b按引用传递以外，其他变量按值传递，无返回值类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-捕获方式总结"><a href="#3-2-捕获方式总结" class="headerlink" title="3.2 捕获方式总结"></a>3.2 捕获方式总结</h3><p><strong>lambda捕获列表</strong>由多个捕获项组成，并以逗号分隔开。捕获列表有如下几种形式：</p><ul><li><strong>[var]</strong>: 表示值捕获变量<em>var</em></li><li><strong>[&#x3D;]</strong>:表示值传递方式捕获所有父作用域的变量，包括this</li><li><strong>[&amp;var]</strong> :表示引用传递捕获变量var</li><li><strong>[&amp;]</strong>:表示引用传递方式捕获所有父作用域的变量，包括this</li><li><strong>[this]</strong>: 表示值传递的方式捕获this指针</li><li><strong>[&#x3D;,&amp;a,&amp;b]</strong>:表示引用传递的方式捕获变量a和b，值传递方式捕获所有父作用域变量</li></ul><h2 id="lambda函数使用场景"><a href="#lambda函数使用场景" class="headerlink" title="lambda函数使用场景"></a>lambda函数使用场景</h2><ol><li>当使用algorithm排序搜索的算法时，可<strong>替代普通函数作为比较函数</strong>，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 初始化vector容器</span></span><br><span class="line">   std::vector&lt;<span class="type">int</span>&gt; vecNums&#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">22</span> &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 用lambda函数做比较函数，进行升序排序</span></span><br><span class="line">   std::<span class="built_in">sort</span>(vecNums.<span class="built_in">begin</span>(), vecNums.<span class="built_in">end</span>(), [](<span class="type">int</span>&amp; nNum1, <span class="type">int</span>&amp; nNum2) &#123;</span><br><span class="line">   <span class="keyword">return</span> nNum1 &lt; nNum2;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打印vecNums</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : vecNums)</span><br><span class="line">   &#123;</span><br><span class="line">   std::cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vecNums排序后：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">22</span></span><br></pre></td></tr></table></figure><ol start="2"><li>当使用std::thread多线程编程时，如果线程中函数代码量很小，可直接在<strong>线程创建时候使用lambda函数</strong>，无需额外定义一个普通函数，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 打印主线程ID</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子线程中打印子主线程ID</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;子线程的线程ID: &quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞调用线程，在这里是主线程，防止主线程先于子线程结束</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主线程的线程ID: <span class="number">26884</span></span><br><span class="line">子线程的线程ID: <span class="number">28900</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>lambda函数</strong>是C++11标准引入的，主要用于提高代码的灵活性，能够减少代码量，将复杂的代码分解成简单的函数调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-11-lambda表达式&quot;&gt;&lt;a href=&quot;#C-11-lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;C++11 lambda表达式&quot;&gt;&lt;/a&gt;C++11 lambda表达式&lt;/h1&gt;&lt;h2 id=&quot;1-简介与使用&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="C++" scheme="https://onlyna.github.io/categories/C/"/>
    
    
    <category term="C++ 11" scheme="https://onlyna.github.io/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>WSL 中文字符编码问题</title>
    <link href="https://onlyna.github.io/everyday/wsl-encoding-issue/"/>
    <id>https://onlyna.github.io/everyday/wsl-encoding-issue/</id>
    <published>2024-09-01T14:58:16.000Z</published>
    <updated>2024-09-06T17:40:16.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WSL-中文字符编码问题"><a href="#WSL-中文字符编码问题" class="headerlink" title="WSL 中文字符编码问题"></a>WSL 中文字符编码问题</h1><p>在使用 Windows Subsystem for Linux (WSL) 进行开发时，一些用户可能会遇到在 WSL<br>终端中显示中文时出现乱码的问题。这种问题可以影响到日常开发和命令行工具的使用。本文将介绍几种常见的解决方法来解决 WSL<br>中文乱码问题。</p><h2 id="方法一：设置字符编码"><a href="#方法一：设置字符编码" class="headerlink" title="方法一：设置字符编码"></a>方法一：设置字符编码</h2><p>在终端中执行以下命令，将终端的字符编码设置为 UTF-8：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br><span class="line"><span class="built_in">export</span> LC_ALL=en_US.UTF-8</span><br></pre></td></tr></table></figure><p>然后，重新启动终端并尝试输入中文字符，应该能够正确显示中文字符了。</p><h2 id="方法二：安装中文字体"><a href="#方法二：安装中文字体" class="headerlink" title="方法二：安装中文字体"></a>方法二：安装中文字体</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install fonts-wqy-zenhei</span><br></pre></td></tr></table></figure><p>安装完成后，重新启动终端或注销并重新登录，然后尝试输入中文字符，应该能够正常显示了。</p><h2 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h2><h3 id="关于WSL显示GUI-APP"><a href="#关于WSL显示GUI-APP" class="headerlink" title="关于WSL显示GUI APP"></a>关于WSL显示GUI APP</h3><ol><li>选择“开始”，键入 PowerShell，右键单击“Windows PowerShell”，然后选择“以管理员身份运行”。</li><li>输入 WSL 更新命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --update</span><br></pre></td></tr></table></figure></li><li>需要重启 WSL 才能使更新生效。可以通过在 PowerShell 中运行关闭命令来重新启动 WSL。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure></li><li>完成，此外运行vscode等gui app时可以直接显示gui窗口。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WSL-中文字符编码问题&quot;&gt;&lt;a href=&quot;#WSL-中文字符编码问题&quot; class=&quot;headerlink&quot; title=&quot;WSL 中文字符编码问题&quot;&gt;&lt;/a&gt;WSL 中文字符编码问题&lt;/h1&gt;&lt;p&gt;在使用 Windows Subsystem for Linu</summary>
      
    
    
    
    
    <category term="日常" scheme="https://onlyna.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>自动类型推导</title>
    <link href="https://onlyna.github.io/cplusplus/auto-type/"/>
    <id>https://onlyna.github.io/cplusplus/auto-type/</id>
    <published>2024-09-01T14:12:23.000Z</published>
    <updated>2024-09-06T17:40:16.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-auto"><a href="#1-auto" class="headerlink" title="1. auto"></a>1. auto</h1><blockquote><p>在 <strong>C++11</strong> 中，引入了许多新的特性，例如 <code>auto</code> 关键字用于自动推导变量的类型，同时结合 <code>decltype</code><br>可以明确表示函数的返回值。这些特性使得代码更加简洁和现代化，提升了编程效率和可维护性。利用这些新特性，我们能够编写出更加优雅和高效的代码。</p></blockquote><h2 id="1-1-基本推导规则"><a href="#1-1-基本推导规则" class="headerlink" title="1.1 基本推导规则"></a>1.1 基本推导规则</h2><p>当使用 <code>auto</code> 声明一个变量时，编译器根据初始化表达式的类型来推导变量的类型。推导的类型与初始化表达式的类型相同。使用语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> variable = expression; <span class="meta"># auto 变量名 = 变量值</span></span><br></pre></td></tr></table></figure><p>简单使用例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>;        <span class="comment">// x 的类型是 int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.14</span>;      <span class="comment">// y 的类型是 double</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// z 的类型是 const char*</span></span><br></pre></td></tr></table></figure><h2 id="1-2-引用和指针"><a href="#1-2-引用和指针" class="headerlink" title="1.2 引用和指针"></a>1.2 引用和指针</h2><p>如果初始化表达式是一个引用或指针，<code>auto</code> 推导的类型也会是对应的引用或指针类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp; ref = a;    <span class="comment">// ref 的类型是 int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>* ptr = &amp;a;   <span class="comment">// ptr 的类型是 int*</span></span><br></pre></td></tr></table></figure><h2 id="1-3-常量与非常量"><a href="#1-3-常量与非常量" class="headerlink" title="1.3 常量与非常量"></a>1.3 常量与非常量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> x = ci;       <span class="comment">// x 的类型是 const int</span></span><br></pre></td></tr></table></figure><h2 id="1-4-类型推导与-auto-和-auto"><a href="#1-4-类型推导与-auto-和-auto" class="headerlink" title="1.4 类型推导与 auto&amp; 和 auto&amp;&amp;"></a>1.4 类型推导与 <em>auto&amp;</em> 和 <em>auto&amp;&amp;</em></h2><ul><li><code>auto&amp;</code>（左值引用）: 推导出的类型是初始化表达式的左值引用类型。</li><li><code>auto&amp;&amp;</code>（万能引用&#x2F;右值引用）: 推导出的类型是初始化表达式的右值引用类型，但也可以推导为左值引用，如果初始化表达式是左值的话。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp; ref = a;     <span class="comment">// ref 的类型是 int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; rval = <span class="number">10</span>;  <span class="comment">// rval 的类型是 int&amp;&amp;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="1-5-模板和-auto"><a href="#1-5-模板和-auto" class="headerlink" title="1.5 模板和 auto"></a>1.5 模板和 auto</h2><p>在模板中，<code>auto</code> 可以用于自动推导模板参数类型，但不能用于函数参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; # 返回类型是 <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-auto-与-std-initializer-list"><a href="#1-6-auto-与-std-initializer-list" class="headerlink" title="1.6 auto 与 std::initializer_list"></a>1.6 auto 与 std::initializer_list</h2><p><code>auto</code>不能直接推导 std::initializer_list 的类型，需要显式指定类型或使用 <code>decltype</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> list = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// list 的类型是 std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>auto</code> 关键字在 C++11 中的引入简化了类型声明，通过自动推导变量类型，提高了代码的可读性和维护性。理解 <code>auto</code> 的推导规则可以帮助你更有效地使用它。在使用 <code>auto</code> 时，要注意它的推导规则，特别是在处理引用、指针、常量以及函数返回类型时。</p><h1 id="2-decltype"><a href="#2-decltype" class="headerlink" title="2. decltype"></a>2. decltype</h1><p><code>decltype</code> 是 <strong>C++11</strong> 引入的一个关键字，用于在编译时查询表达式的类型。它允许我们获取表达式的实际类型，无论该类型是内置类型、用户定义的类型，还是表达式的复杂类型。<code>decltype</code> 与 <code>auto</code> 关键字常常结合使用，可以在某些情况下提供更精确的类型推导。</p><h2 id="2-1-decltype-基本用法"><a href="#2-1-decltype-基本用法" class="headerlink" title="2.1 decltype 基本用法"></a>2.1 <code>decltype</code> 基本用法</h2><h3 id="2-1-1-基本语法"><a href="#2-1-1-基本语法" class="headerlink" title="2.1.1 基本语法"></a>2.1.1 基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression) variable;</span><br></pre></td></tr></table></figure><p><code>decltype</code> 会根据 <strong>expression</strong> 的类型来推导 <strong>variable</strong> 的类型。</p><h3 id="2-1-2-实例"><a href="#2-1-2-实例" class="headerlink" title="2.1.2 实例"></a>2.1.2 实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">20</span>;  <span class="comment">// y 的类型是 int，与 x 相同</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = x;</span><br><span class="line"><span class="keyword">decltype</span>(ref) newRef = x; <span class="comment">// newRef 的类型是 const int&amp;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>decltype(x)</code> 和 <code>decltype(ref)</code> 会分别推导为 <code>int</code> 和 <code>const int&amp;</code>，确保 <code>y</code> 和 <code>newRef</code> 具有正确的类型。</p><h2 id="2-2-使用-decltype-的场景"><a href="#2-2-使用-decltype-的场景" class="headerlink" title="2.2 使用 decltype 的场景"></a>2.2 使用 decltype 的场景</h2><h3 id="2-2-1-推导复杂类型"><a href="#2-2-1-推导复杂类型" class="headerlink" title="2.2.1 推导复杂类型"></a>2.2.1 推导复杂类型</h3><p><code>decltype</code> 特别有用在处理复杂类型时，例如函数的返回类型或者模板中需要精确类型的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">decltype</span>(vec.<span class="built_in">begin</span>()) it = vec.<span class="built_in">begin</span>(); <span class="comment">// it 的类型是 std::vector&lt;int&gt;::iterator</span></span><br></pre></td></tr></table></figure><h3 id="2-2-2-结合-auto-和-decltype-使用"><a href="#2-2-2-结合-auto-和-decltype-使用" class="headerlink" title="2.2.2 结合 auto 和 decltype 使用"></a>2.2.2 结合 <code>auto</code> 和 <code>decltype</code> 使用</h3><p><code>auto</code> 用于自动推导类型，<code>decltype</code> 用于获取表达式的类型。两者结合使用可以实现更灵活的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="keyword">decltype</span>(a + b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;  <span class="comment">// 返回类型由 a + b 决定</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-3-获取成员类型"><a href="#2-2-3-获取成员类型" class="headerlink" title="2.2.3 获取成员类型"></a>2.2.3 获取成员类型</h3><p><code>decltype</code> 可以用于获取类成员的类型，尤其在模板中处理成员类型时非常有用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(MyStruct::x) y = <span class="number">5</span>;  <span class="comment">// y 的类型是 int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-4-使用-decltype-作为函数返回类型"><a href="#2-2-4-使用-decltype-作为函数返回类型" class="headerlink" title="2.2.4 使用 decltype 作为函数返回类型"></a>2.2.4 使用 <code>decltype</code> 作为函数返回类型</h3><p><code>decltype</code> 可以用于函数的返回类型，确保返回类型与某个表达式的类型一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">multiply</span>(<span class="number">1</span>, <span class="number">2</span>)) result;  <span class="comment">// result 的类型是 int</span></span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><code>decltype</code> 是一个强大的工具，用于在编译时查询表达式的类型。它提供了精确的类型推导能力，特别适合处理复杂类型和模板编程。通过合理使用 <code>decltype</code>，可以使代码更加灵活和准确，减少类型相关的错误。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-auto&quot;&gt;&lt;a href=&quot;#1-auto&quot; class=&quot;headerlink&quot; title=&quot;1. auto&quot;&gt;&lt;/a&gt;1. auto&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在 &lt;strong&gt;C++11&lt;/strong&gt; 中，引入了许多新的特性，例如</summary>
      
    
    
    
    <category term="C++" scheme="https://onlyna.github.io/categories/C/"/>
    
    
    <category term="C++ 11" scheme="https://onlyna.github.io/tags/C-11/"/>
    
  </entry>
  
</feed>
